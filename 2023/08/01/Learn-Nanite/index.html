

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="Virtual Geometry build-in MapleEngine. Fake Nanite implementation.">
  <meta name="author" content="Prime">
  <meta name="keywords" content="Graphics Game Engine OpenGL C++ Vulkan">
  
  <title>Fake-Nanite - Portfolio</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"flwmxd.github.io","root":"/","version":"1.8.9","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":6},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Prime`s Portfolio</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/back2.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Fake-Nanite">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2023-08-01 23:00" pubdate>
        August 1, 2023 pm
      </time>
    </span>
  
</div>

<div class="mt-1">
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      27
       minutes
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Fake-Nanite</h1>
            
            <div class="markdown-body">
              <h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Implement Nanite in my personal Game Engine( it is an experimental function now).<br>the goal is to learn Nanite system.</p>
<p align="center">
<iframe width="560" height="315" src="https://www.youtube.com/embed/79aaFzgOso0" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
</p>

<p align="center">
<iframe width="560" height="315" src="https://www.youtube.com/embed/xQeqNVvb6rM" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
</p>

<h2 id="What-we-need-in-next-generation-model-Rendering"><a href="#What-we-need-in-next-generation-model-Rendering" class="headerlink" title="What we need in next generation model Rendering?"></a>What we need in next generation model Rendering?</h2><p>To achieve a lifelike cinematic cutscene, character models need to be incredibly detailed; for a sufficiently flexible and rich open world, both the map size and the number of objects need to grow exponentially. Both of these factors significantly increase the demands on scene intricacy and complexity: the quantity of scene objects needs to be high, and each model needs to be finely detailed.</p>
<p>There are typically two bottlenecks when it comes to rendering complex scenes: (1) the CPU-side validation and CPU-GPU communication overhead caused by each Draw Call; (2) the overdraw resulting from imprecise occlusion culling, leading to wastage of GPU computational resources. In recent years, optimizations in rendering technology have often revolved around these two challenges, leading to some industry-wide technical consensus.</p>
<ul>
<li>the one is next generation graphics API (Vulkan/DX12)</li>
<li>another one is <strong>GPU Driven Pipeline</strong></li>
</ul>
<p>Thanks to the increasingly widespread adoption of the GPU Driven Pipeline in games, further subdividing the vertex data of models into Clusters (or Meshlets) has become a best practice for optimizing complex scenes. This approach allows each cluster to better align with the cache size of the Vertex Processing stage. Various culling techniques like Frustum Culling, Occlusion Culling, and Backface Culling are then applied on a per-cluster basis, effectively optimizing intricate scenes.</p>
<h2 id="Is-that-enough"><a href="#Is-that-enough" class="headerlink" title="Is that enough ?"></a>Is that enough ?</h2><p>At this point, the issues related to the number of models, triangle vertices, and faces have been greatly optimized and improved. However, high-poly models and pixel-level small triangles introduce new challenges to the rendering pipeline: the pressures of rasterization and overdraw.</p>
<h2 id="Is-there-a-chance-for-soft-rasterization-to-defeat-hard-rasterization"><a href="#Is-there-a-chance-for-soft-rasterization-to-defeat-hard-rasterization" class="headerlink" title="Is there a chance for soft rasterization to defeat hard rasterization?"></a>Is there a chance for soft rasterization to defeat hard rasterization?</h2><p>In simple terms, traditional hardware design for rasterization initially envisioned input triangles that are much larger than a single pixel. Based on this idea, the rasterization process in hardware is typically hierarchical. Taking the example of the rasterizer in an NVIDIA graphics card, a triangle usually goes through two stages of rasterization: Coarse Raster and Fine Raster.</p>
<h3 id="Coarse-Raster"><a href="#Coarse-Raster" class="headerlink" title="Coarse Raster"></a>Coarse Raster</h3><p>In the Coarse Raster stage, a triangle is taken as input and divided into blocks of 8x8 pixels each. This means the triangle is rasterized into several of these blocks, effectively performing a rough rasterization on a framebuffer that’s 1/8th the size of the original framebuffer. In this stage, using a low-resolution Z-buffer, hidden blocks that are occluded are culled out—referred to as Z Culling. After Coarse Raster, the blocks that pass through Z Culling are sent to the next stage, Fine Raster, where the final pixels for shading calculations are generated.</p>
<h3 id="Fine-Raster"><a href="#Fine-Raster" class="headerlink" title="Fine Raster"></a>Fine Raster</h3><p>In the Fine Raster stage, we encounter the concept of Early Z. Due to the computation required for mip-map sampling, it’s necessary to know information about neighboring pixels for each pixel and to use the differences in sampled UV coordinates as the basis for mip-map level calculations. Consequently, the output of the Fine Raster stage isn’t individual pixels, but rather 2x2 mini pixel blocks known as Pixel Quads.</p>
<p>For triangles that are close to the size of a single pixel, the inefficiency of hardware rasterization becomes evident. Firstly, the Coarse Raster stage is almost useless in such cases, as these triangles are typically smaller than 8x8 pixels. For elongated triangles, this situation is even worse since a triangle might span multiple blocks, and Coarse Raster not only fails to cull these blocks but also adds extra computational load. Additionally, for large triangles, the Fine Raster stage based on Pixel Quads only generates a few useless pixels along the edges compared to the overall triangle area. However, for small triangles, Pixel Quads can generate up to four times the number of pixels as the triangle’s area, and these pixels are also included in the execution of the pixel shader, significantly reducing the number of effective pixels in a warp.</p>
<p>Based on the reasons mentioned above, under the specific premise of small triangles at the pixel level, software rasterization (based on Compute Shader) indeed has the potential to outperform hardware rasterization. </p>
<h1 id="Deferred-rendering"><a href="#Deferred-rendering" class="headerlink" title="Deferred rendering"></a>Deferred rendering</h1><p>Generally speaking, deferred rendering pipelines require a set of Render Targets called G-Buffer, where all the material information needed for lighting calculations is stored. In today’s AAA games, the variety of materials often becomes complex and diverse, leading to a gradual increase in the information that needs to be stored in the G-Buffer.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Pass 0: Render all meshes, output material data.</span><br><span class="hljs-function">BrdfData <span class="hljs-title">MaterialPS</span><span class="hljs-params">(Interpolators interp)</span></span><br><span class="hljs-function"></span>&#123;<br>  BrdfData  brdfData  = <span class="hljs-built_in">MaterialEval</span>(interp);<br>  <span class="hljs-keyword">return</span> brdfData;<br>&#125;<br><br><span class="hljs-comment">// Pass 1: Compute shader (or large quad) to calculate lighting.</span><br><span class="hljs-function">LightData <span class="hljs-title">LightingCS</span><span class="hljs-params">(float2 screenPos)</span></span><br><span class="hljs-function"></span>&#123;<br>  BrdfData  brdfData  = <span class="hljs-built_in">FetchMaterial</span>(screenPos);<br>  LightData lightData = <span class="hljs-built_in">LightingEval</span>(brdfData);<br>  <span class="hljs-keyword">return</span> lightData;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="Visibility-Buffer"><a href="#Visibility-Buffer" class="headerlink" title="Visibility Buffer"></a>Visibility Buffer</h1><p>For scenes with high overdraw, the read-write bandwidth generated by G-Buffer rendering often becomes a performance bottleneck. As a result, a new rendering pipeline called the <strong>Visibility Buffer</strong> has been proposed. Algorithms based on the Visibility Buffer approach no longer generate a bulky G-Buffer separately; instead, they use a lower bandwidth-consuming Visibility Buffer as a substitute. The Visibility Buffer typically requires the following information:</p>
<ul>
<li>(1) InstanceID, indicating which Instance the current pixel belongs to (16~24 bits);</li>
<li>(2) PrimitiveID, indicating which triangle of the Instance the current pixel belongs to (8~16 bits);</li>
<li>(3) Barycentric Coord, representing the position of the current pixel within the triangle using barycentric coordinates (16 bits);</li>
<li>(4) Depth Buffer, representing the depth of the current pixel (16~24 bits);</li>
<li>(5) MaterialID, indicating which material the current pixel belongs to (8~16 bits).</li>
</ul>
<p>In the above approach, we only need to store approximately 8~12 Bytes/Pixel to represent the material information of all geometry in the scene. Simultaneously, we need to maintain a global vertex data and material texture table, containing the vertex data for all geometry in the current frame, as well as material parameters and textures. During the lighting and shading phase, it’s only necessary to index relevant triangle information from the global Vertex Buffer based on InstanceID and PrimitiveID. Moreover, using the barycentric coordinates of the pixel, interpolate the per-pixel information from the Vertex Buffer, including UV coordinates, Tangent Space, and other attributes. Furthermore, use the MaterialID to index relevant material information, execute texture sampling operations, and input these into the lighting calculation stage to ultimately complete the shading process. Sometimes, this kind of method is also referred to as Deferred Texturing.</p>
<p>Intuitively, the Visibility Buffer reduces the storage bandwidth required for shading information (from G-Buffer to Visibility Buffer). Additionally, it defers the reading of geometry and texture information related to lighting calculations to the shading phase. Consequently, pixels that are not visible on the screen no longer need to read this data; they only require vertex position information. Due to these two reasons, in high-resolution complex scenes, the bandwidth overhead of the Visibility Buffer is significantly lower compared to traditional G-Buffer approaches.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Pass 0: Rasterize all meshes, just output thin visibility</span><br><span class="hljs-function">U32 <span class="hljs-title">VisibilityPS</span><span class="hljs-params">(U32 drawCallId, U32 triangleId)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> (drawCallId &lt;&lt; NUM_TRIANGLE_BITS) | triangleId;<br>&#125;<br><br><span class="hljs-comment">// Pass 1: In a CS convert from triangle ID to BRDF data</span><br><span class="hljs-function">BrdfData <span class="hljs-title">MaterialCS</span><span class="hljs-params">(float2 screenPos)</span></span><br><span class="hljs-function"></span>&#123;<br>  U32 drawCallId = <span class="hljs-built_in">FetchVisibility</span>() &gt;&gt; NUM_TRIANGLE_BITS;<br>  U32 triangleId = <span class="hljs-built_in">FetchVisibility</span>() &amp;      TRIANGLE_MASK;<br><br>  Interpolators interp    = <span class="hljs-built_in">FetchInterpolators</span>(drawCallId, triangleId);<br>  BrdfData      brdfData  = <span class="hljs-built_in">MaterialEval</span>(interp);<br>  <span class="hljs-keyword">return</span> brdfData;<br>&#125;<br><br><span class="hljs-comment">// Pass 2: In a CS, fetch BRDF data and calculate lighting</span><br><span class="hljs-function">LightData <span class="hljs-title">LightingCS</span><span class="hljs-params">(float2 screenPos)</span></span><br><span class="hljs-function"></span>&#123;<br>  BrdfData      brdfData  = <span class="hljs-built_in">FetchMaterial</span>(screenPos);<br>  LightData     lightData = <span class="hljs-built_in">LightingEval</span>(brdfData);<br>  <span class="hljs-keyword">return</span> lightData;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h1><p>In my implementation, I mainly implemented </p>
<ul>
<li>QEM Simplification.</li>
<li>Basic GPUDriven Culling </li>
<li>VisibilityBuffer Rendering</li>
</ul>
<h2 id="Simplification"><a href="#Simplification" class="headerlink" title="Simplification"></a>Simplification</h2><p>Simplification is based on QEM algorithm which is edge collapsed algorithm.</p>
<p><img src="/images/nanite/qem.jpg" srcset="/img/loading.gif" lazyload></p>
<p>The main idea of the algorithm:</p>
<p>Enumerate each edge and calculate the quadratic error metric for collapsing that edge.<br>Greedily pick the smallest edge.</p>
<ol>
<li>Count all edges participating in edge folding</li>
<li>Calculate QEM(v) of all vertices, calculate QEM(e) of all edges=QEM(v1)+QEM(v2)</li>
<li>Find the smallest QEM(e) edge according to the sorting of QEM(e)</li>
<li>Collapse the edge and find the new vertex v’ with the optimal QEM, delete v1, v2, and related faces, update the QEM of v’ to be QEM(v1)+QEM(v2), and update the associated QEM(e)</li>
<li>Repeat 3, 4 until the requirements are met.</li>
</ol>
<h2 id="How-did-it-work-in-Nanite"><a href="#How-did-it-work-in-Nanite" class="headerlink" title="How did it work in Nanite"></a>How did it work in Nanite</h2>
            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Geometric-Processing/">Geometric Processing</a>
                    
                  </div>
                
              </div>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/08/11/ECS/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Advanced ECS Architecture</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/01/15/SDFGI/">
                        <span class="hidden-mobile">SDFGI</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
    
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js" ></script>

  





  <script  src="https://cdn.jsdelivr.net/npm/mermaid@8.8.3/dist/mermaid.min.js" ></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({"theme":"default"});
    }
  </script>







<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
