

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="An advanced ECS Architecture build-in MapleEngine">
  <meta name="author" content="Prime">
  <meta name="keywords" content="Graphics Game Engine OpenGL C++ Vulkan">
  
  <title>Advanced ECS Architecture - Portfolio</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"flwmxd.github.io","root":"/","version":"1.8.9","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":6},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Prime`s Portfolio</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/back2.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Advanced ECS Architecture">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2023-08-11 00:00" pubdate>
        August 11, 2023 am
      </time>
    </span>
  
</div>

<div class="mt-1">
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      75
       minutes
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Advanced ECS Architecture</h1>
            
            <div class="markdown-body">
              <h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>This article will try to explain the deep understanding of ecs architecture, which include the memory model, how to do in multi-thread with look-free and abstract interface for developer.</p>
<h1 id="CPU-Cache"><a href="#CPU-Cache" class="headerlink" title="CPU-Cache"></a>CPU-Cache</h1><p>Before talking about ecs architecture, I will try to explain an important knowledge “CPU-Cache”. </p>
<p><img src="/images/ecs/cpu-overview.png" srcset="/img/loading.gif" lazyload alt="cpu-overview"></p>
<p>The main purpose of CPU cache is to reduce the latency or delay in data retrieval. When the CPU needs to access data, it first checks whether the data is available in the cache. If the data is present in the cache (cache hit), the CPU can retrieve it much faster than if it had to fetch the data from the main memory (cache miss). This helps to mitigate the performance bottleneck caused by the slower access times of main memory.</p>
<p>There are typically three levels of CPU cache: L1, L2, and L3. These levels form a hierarchy with different sizes and access speeds:</p>
<p>The cache hierarchy is designed to exploit the principle of <strong>spatial and temporal locality</strong>, where programs tend to access data and instructions that are close to what they’ve accessed recently. By keeping frequently accessed data in the cache, the CPU can operate more efficiently and reduce the time spent waiting for data from main memory.</p>
<h2 id="Spatial-and-Temporal-Locality"><a href="#Spatial-and-Temporal-Locality" class="headerlink" title="Spatial and Temporal Locality"></a>Spatial and Temporal Locality</h2><h3 id="Spatial-Locality"><a href="#Spatial-Locality" class="headerlink" title="Spatial Locality"></a>Spatial Locality</h3><p>Spatial locality refers to the tendency of a program to access data located near or close to the data that has been recently accessed. In other words, if a program accesses a particular memory location, it is likely to access nearby memory locations in the near future. This principle is rooted in the idea that data in memory is often stored in contiguous blocks, so accessing one piece of data often implies accessing neighboring data as well.<br>For example, when iterating over an array in a loop, spatial locality suggests that the next element to be accessed is likely to be stored in close proximity to the current element. Caches exploit spatial locality by fetching entire <strong>cache lines (blocks of contiguous memory)</strong> when a memory location is accessed. This way, if a program accesses one piece of data, it’s likely to access other nearby data soon, improving cache hit rates.</p>
<h3 id="Temporal-Locality"><a href="#Temporal-Locality" class="headerlink" title="Temporal Locality"></a>Temporal Locality</h3><p>Temporal locality refers to the tendency of a program to access the same data or instructions repeatedly over a short period of time. In other words, if a piece of data is accessed once, it’s likely to be accessed again in the near future. This principle is based on the observation that programs often exhibit repetitive behavior and reuse the same data multiple times within a short timeframe.<br>For instance, in a loop that processes the same data multiple times, temporal locality implies that the loop will repeatedly access the same data elements. Caches leverage temporal locality by keeping recently accessed data in the cache. If a piece of data is accessed once and stored in the cache, subsequent accesses to the same data can be served quickly from the cache.</p>
<h2 id="Who-is-Faster"><a href="#Who-is-Faster" class="headerlink" title="Who is Faster ?"></a>Who is Faster ?</h2><p>Assuming there is a matrix(N x M), we have these two approaches to iterate. which one is faster?</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;N; I++)<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;M; j++) <br>             <span class="hljs-built_in">print</span>(matrix[i][j]);<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;M; I++)<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;N; j++) <br>             <span class="hljs-built_in">print</span>(matrix[j][i]);<br></code></pre></td></tr></table></figure>
<h3 id="Iteration-By-Row"><a href="#Iteration-By-Row" class="headerlink" title="Iteration By Row"></a>Iteration By Row</h3><p>the answer is the <strong>first one</strong>. but why?  we use an example to explain. Look at the picture below. (ignored L3 cache.)</p>
<p>we use the first approch to iterate means iterating by row.</p>
<p>when the CPU wants to access matrix, it is not cache. so it would load a <strong>cache line</strong> into L2/L1.<br><img src="/images/ecs/load2.png" srcset="/img/loading.gif" lazyload alt="cpu-load into L2"><br><img src="/images/ecs/load3.png" srcset="/img/loading.gif" lazyload alt="cpu-load into L1"></p>
<p>now the cache line is mapped into L1/L2, the CPU can access matrix[N][0], matrix[N][1], matrix[N][2], etc quickly becuase they are in a contiguous block.</p>
<h3 id="Iteration-By-Column"><a href="#Iteration-By-Column" class="headerlink" title="Iteration By Column"></a>Iteration By Column</h3><p><img src="/images/ecs/load-by-column.png" srcset="/img/loading.gif" lazyload alt="load-by-column"></p>
<p>but if we iterate matrix by column, in most cases the elements matrix[0][M] , matrix[1][M], and matrix[2][M] are not contiguous, which would cause a very high-frequency cache miss. Thus, the overall efficiency would be slower.</p>
<h1 id="ECS-Architecture-at-First-impression"><a href="#ECS-Architecture-at-First-impression" class="headerlink" title="ECS Architecture at First impression"></a>ECS Architecture at First impression</h1><p>The most obvious implementation of a component based model is the one that involves maps (or sort of) and objects taken directly from the typical OOP world</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown">void system(std::vector<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">GameObjects</span>&gt;</span></span> &amp;objects) &#123;<br><span class="hljs-code">    for(auto &amp;object: objects) &#123;</span><br><span class="hljs-code">        if(object.has&lt;position, velocity&gt;()) &#123;</span><br><span class="hljs-code">            auto &amp;pos = object.get&lt;position&gt;();</span><br><span class="hljs-code">            auto &amp;vel = object.get&lt;velocity&gt;();</span><br><span class="hljs-code">            //handle your logic.</span><br><span class="hljs-code">        &#125;</span><br><span class="hljs-code">    &#125;</span><br><span class="hljs-code">&#125;</span><br></code></pre></td></tr></table></figure>

<h2 id="Memory-Model"><a href="#Memory-Model" class="headerlink" title="Memory Model"></a>Memory Model</h2><p>In this example, so the memory looks like this. </p>
<pre><code class=" mermaid">stateDiagram-v2
    position --&gt; object
    velocity --&gt; object
    components --&gt; object

    position2 --&gt; object2
    velocity2 --&gt; object2
    components2 --&gt; object2

</code></pre>

<h2 id="Problems"><a href="#Problems" class="headerlink" title="Problems ?"></a>Problems ?</h2><ul>
<li>components are scattered around in memory and you’ve multiple jumps each and every time you access them.<ul>
<li>you don’t know at any time what are the game objects that match a given query and thus you must iterate all of them in each system</li>
<li>thus, there is a big performance issue.</li>
</ul>
</li>
</ul>
<h1 id="ECS-Architecture-at-Second-impression"><a href="#ECS-Architecture-at-Second-impression" class="headerlink" title="ECS Architecture at Second impression"></a>ECS Architecture at Second impression</h1><p>From the last example, we can see that <strong>the GameObject</strong> were nothing more than <strong>containers</strong> for components</p>
<ul>
<li>Components were stored in maps by game objects and every game object had its own set of components. <ul>
<li>Thus, It should be quite easy to get rid of these wrappers and change a bit the layout, so that components of a same type are stored together. it could look like this.</li>
</ul>
</li>
</ul>
<p>and then we can try to get rid of object and rename it to entity, becuase it is pointless. </p>
<pre><code class=" mermaid">graph LR
entity1 --&gt; entity2 --&gt; entity3 --&gt; entity4 --&gt;  entityN
component --&gt; component2 --&gt; component3 --&gt; component4 --&gt; componentN 
</code></pre>

<p>but there is a problem, not all entities have same components. thus there are some solutions to solve it.</p>
<h2 id="Code-Appearance"><a href="#Code-Appearance" class="headerlink" title="Code Appearance"></a>Code Appearance</h2><p>ECS Architecture is totally different with OOP. so for each object, we can call it as <strong>entity</strong>, in this case it is only an integer for representing current object id and managed by central registry .<br>in order to accelerating accessing components data, each components would be storaged in a pools( continous memory block );</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Registry</span>&#123;<br><br>   <span class="hljs-function">entityId <span class="hljs-title">create</span><span class="hljs-params">()</span></span>&#123;....&#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;Comp&gt;</span><br><span class="hljs-function">   Comp&amp; <span class="hljs-title">emplace</span><span class="hljs-params">(Args&amp;&amp;...args)</span></span>&#123;....&#125;<br><br>   SparseSet&lt;entity&gt; entites;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;Comp&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">StoragePool</span><br>&#123;<br>   Comp[MAX_LENGHT] componts;<br>&#125;<br></code></pre></td></tr></table></figure>


<h2 id="Archetypes"><a href="#Archetypes" class="headerlink" title="Archetypes"></a>Archetypes</h2><p>The idea behind this approach can be summarized as follows: if an entity has a particular set of components, take the pool (also known as archetype) for the entities that have that same set (if it doesn’t already exist, create it) and assign the entity and all its components to that pool. Whenever you add/remove a component to/from an entity, pick up everything again and move the entity and all its components from a pool to the other, from an archetype to the other.</p>
<p><img src="/images/ecs/ArchetypeDiagram.png" srcset="/img/loading.gif" lazyload alt="Archetypes"></p>
<ul>
<li>How does archetypes solve the problem of finding all the entities that have certain components?<ul>
<li><em><strong>The triditional way</strong></em> is iterating all the entities and test them to know if they have the desired components.</li>
<li><em><strong>The Archetype solution</strong></em> is iterating all the archetypes (much less than the entities), then return all the entities from the archetypes that are built for a set of components that contains at least the desired ones.</li>
</ul>
</li>
<li>What are the drawbacks ?<ul>
<li>Every time a component is added or removed, an entity and all its components are moved from an archetype to another one. This affects to an extent the construction and destruction of components</li>
<li>Main issue is the archetypes’s fragmentation. which means if you have a high number of possible combinations of components assigned to different entities at runtime and this will definitely affect the iterations to an extent by adding more and more jumps to find all the entities.</li>
</ul>
</li>
</ul>
<h2 id="Sparse-Sets"><a href="#Sparse-Sets" class="headerlink" title="Sparse Sets"></a>Sparse Sets</h2><p>It is different from Archetypes approach. Sparse sets is a clever data structure for storing sparse sets of integers on the range 0 .. u−1 and performing initialization, lookup, and insertion is time O(1) and iteration in O(n), where n is the number of elements in the set.</p>
<ul>
<li>in short, the sparse set would provides two array. one is <strong>dense[]</strong>, another one is <strong>sparse[]</strong>.</li>
</ul>
<p><img src="/images/ecs/sparse0b.png" srcset="/img/loading.gif" lazyload alt="SparseSets"></p>
<p>the indirection isn’t required when you want to iterate all the values contained by the sparse set. It’s suffice to walk through the <strong>dense</strong> for that, from the first to the last.</p>
<p>how can we use the SpareSet to organize components? we can use the sparse set to create to pool and put components (look at the graph)</p>
<p><img src="/images/ecs/components.png" srcset="/img/loading.gif" lazyload alt="organize components"></p>
<h4 id="Problems-1"><a href="#Problems-1" class="headerlink" title="Problems"></a>Problems</h4><p>but there still are some problems, if we only iterate one component, that must be faster. but if we want to iterate entities which contain component <strong>position</strong> and <strong>velocity</strong>. How do we do?</p>
<h2 id="View"><a href="#View" class="headerlink" title="View"></a>View</h2><p>The first implementation is <strong>view</strong>. which also provies <strong>single</strong> type views and <strong>multi-type</strong> views.</p>
<h3 id="Single-Views"><a href="#Single-Views" class="headerlink" title="Single Views"></a>Single Views</h3><p>Single type views are specialized to give a performance boost in all cases. (that’s because each components are in contious memory block and cache-friendly)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> singleView = registry.<span class="hljs-built_in">view</span>&lt;position&gt;();<br></code></pre></td></tr></table></figure>

<p>There is nothing as fast as a single type view. They just walk through packed (actually paged) arrays of elements and return them directly.</p>
<pre><code class=" mermaid">graph LR
entity1 --&gt; entity2 --&gt; entity3 --&gt; entity4 --&gt;  entityN
position --&gt; position2 --&gt; position3 --&gt; position4--&gt; position5
</code></pre>

<h3 id="Multi-Type-Views"><a href="#Multi-Type-Views" class="headerlink" title="Multi Type Views"></a>Multi Type Views</h3><p>Multi type views iterate entities that have at least all the given components. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> muiltView = registry.<span class="hljs-built_in">view</span>&lt;position,velocity&gt;();<br></code></pre></td></tr></table></figure>

<pre><code class=" mermaid">graph

subgraph entity
entity1 --&gt; entity2 --&gt; entity3 --&gt; entity4 --&gt;  entityN
end

subgraph positon pool
position --&gt; position2 --&gt; position3 --&gt; position4--&gt; position5
end

subgraph velocity pool
velocity1 --&gt; velocity2 --&gt; velocity4
end

entity1 --&gt; velocity1
entity2 --&gt; velocity2
entity4 --&gt; velocity4

</code></pre>
<p>During construction, they look at the number of elements available in each pool and use the <strong>smallest set</strong> in order to speed up iterations.</p>
<pre><code class=" mermaid">graph LR

subgraph entity
entity1 --&gt; entity2 --&gt; entity4
end

subgraph velocity pool
velocity1 --&gt; velocity2 --&gt; velocity4
end
</code></pre>
<p>The performance is good when you <strong>only</strong> fetch velocity component(because it was the smallest set). but the performance could cause slower when you try to access other components becuase it would use indirect look-up.</p>
<pre><code class=" mermaid">graph LR
EntityId --&gt; ArrayIndexId --&gt; OtherComponent

</code></pre>

<p>So is there any way to boost the performance when you want to iterate <strong>more components</strong> ?</p>
<p>The anwser is <strong>Group</strong>.</p>
<h2 id="Group"><a href="#Group" class="headerlink" title="Group"></a>Group</h2><p>Consider you want to iterate components <strong>position</strong> and <strong>velocity</strong>. Because of the way sparse sets work, you know components are all tightly packed in two arrays. Both of them contain some entities that have both the components and some others that have only one of the components. If you can arrange things so that all the entities that have both the components are at the top of the arrays while all the others are at the end, as a result the components will also be arranged accordingly(see the picture). Iterations will benefit indecently from how things are laid out in this case, because all the entities that have both the components and the components themselves are tightly packed and sort in the same way at the beginning of their arrays. </p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>Let’s take an example.</p>
<p>Imagine you have two sparse sets, one for the component <strong>A</strong> and one for the component <strong>B</strong>. They already contain some entities, none of which have both the components. A group for (A, B) is <strong>empty</strong> at this point:<br><img src="/images/ecs/group_case1.png" srcset="/img/loading.gif" lazyload alt="group_case1"></p>
<p>Let’s add <strong>B</strong> to <strong>entity e7</strong> and see how it works. When you do that, you’re guaranteed that <strong>e7</strong> isn’t part of the group yet, mainly because it didn’t have B before.<br>Immediately after adding B to entity e7, the sparse sets will appear as follows:<br><img src="/images/ecs/group_case2.png" srcset="/img/loading.gif" lazyload alt="group_case2"></p>
<p>All what is needed now is to literally move the entity e7 within the group(by swaping).<br><img src="/images/ecs/group_case3.png" srcset="/img/loading.gif" lazyload alt="group_case3"></p>
<p>What if we add A to the entity e4 then? That’s easy, same operations and the group keeps growing up:<br><img src="/images/ecs/group_case4.png" srcset="/img/loading.gif" lazyload alt="group_case4"></p>
<p>However, there is a price to pay for this, as for everything else. In this case, the creation and destruction of components is affected by a group to an extent. Nothing that you’ll really notice in real world applications probably, mainly because construction and destruction aren’t usually done along critical paths and it’s unlikely you’re to construct or destroy 1M entities or components every tick. </p>
<p>but if we see the memory structure/model, there still have some approaches to optimize. the approach we call it <strong>ownership</strong>.</p>
<h3 id="Full-owning-groups"><a href="#Full-owning-groups" class="headerlink" title="Full-owning groups"></a>Full-owning groups</h3><p>Full-owning groups are such that they literally own all the pools of their types of components.<br>This is the fastest group (as in fast to iterate entities and components) you can construct. Cache misses are intuitively reduced to a minimum.</p>
<p>But in most time, we can not have the ideal model. </p>
<h3 id="Partial-owning-groups"><a href="#Partial-owning-groups" class="headerlink" title="Partial-owning groups"></a>Partial-owning groups</h3><p>What if I want to define two groups, one for components <strong>A</strong> and <strong>B</strong>, the other one for components <strong>B</strong> and <strong>C</strong>?<br><img src="/images/ecs/group_boost.png" srcset="/img/loading.gif" lazyload alt="group_boost"></p>
<p>Let our first group take ownership of components A and B and therefore be a full-owning group. The second group will take then the ownership of C and will use B as a <strong>free-type</strong>, that is a type of component that takes part in the definition of the group but in whose packed array we cannot create a subset.</p>
<p>Iterations will benefit quite a lot from this. First of all, the extent of the group tells us the exact number of entities to return. Even more, we know exactly what these entities are, because the sparse set of C has them at the top of its array, ordered the same of their components. This is already a huge boost in terms of performance. To get B, instead, we will have to pay the price of the <strong>indirection</strong>, fortunately very low due to the properties of the sparse sets. However, we don’t have to test anymore entities to know if they have B because we know that they have it, being them in the group. We can then go directly to the component and return it.</p>
<h3 id="Non-owning-groups"><a href="#Non-owning-groups" class="headerlink" title="Non-owning groups"></a>Non-owning groups</h3><p>Imagine another case we have three groups: one for components A and B, one for components B and C and one for components A and C.</p>
<p><img src="/images/ecs/group-non-owning.png" srcset="/img/loading.gif" lazyload alt="group-non-owning"></p>
<p>the first one is a full-owning group. The second one is a partial-owning group. Right. What about the third one instead?<br>the third on is <strong>Non-owning</strong>. From the pic, we can see that the there is not element swap, the group only contains the two pools pointer(one is A  pool, another is C pool).<br>Thus, we have to pay extra time indirect component. but the price is not too high.</p>
<h1 id="ECS-Architecture-at-Third-impression"><a href="#ECS-Architecture-at-Third-impression" class="headerlink" title="ECS Architecture at Third impression"></a>ECS Architecture at Third impression</h1><p>From the above article, we have the low level ECS architecture which mainly sloved memory problem and memory optmizations. Let’s see the <strong>basic API</strong> for them.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SparseSet</span>;<span class="hljs-comment">// for memory management </span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Registry</span><span class="hljs-comment">// central registry</span><br>&#123;<br>   <span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">create</span><span class="hljs-params">()</span></span>;<br><br>   <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Comp, <span class="hljs-keyword">typename</span>... Args&gt;</span><br><span class="hljs-function">   <span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">emplace_ctx</span><span class="hljs-params">(Args &amp;&amp;...args)</span></span>;<span class="hljs-comment">//Global Component</span><br><br>   <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Comp&gt;</span><br><span class="hljs-function">   <span class="hljs-keyword">auto</span>&amp; <span class="hljs-title">get_ctx</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//Global Component</span><br><br>   <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Comp, <span class="hljs-keyword">typename</span>... Args&gt;</span><br><span class="hljs-function">   <span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">emplace</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> entity, Args &amp;&amp;...args)</span></span>;<br><br>   <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Owned, <span class="hljs-keyword">typename</span>... Get, <span class="hljs-keyword">typename</span>... Exclude&gt;<br>   Group&lt;TypeList&lt;Owned...&gt;, TypeList&lt;Get...&gt;, TypeList&lt;Exclude...&gt;&gt; <span class="hljs-built_in">group</span>(TypeList&lt;Get...&gt;, TypeList&lt;Exclude...&gt; = &#123;&#125;);<br><br>   <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Owned,<span class="hljs-keyword">typename</span>... Exclude&gt;<br>   Group&lt;TypeList&lt;Owned...&gt;, TypeList&lt;&gt;, TypeList&lt;Exclude...&gt;&gt; <span class="hljs-built_in">group</span>(TypeList&lt;Exclude...&gt; = &#123;&#125;);<br><br>   <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Component, <span class="hljs-keyword">typename</span>... Other, <span class="hljs-keyword">typename</span>... Exclude&gt;<br>   View&lt;TypeList&lt;Component&gt;, TypeList&lt;Other&gt;, TypeList&lt;Exclude...&gt;&gt; <span class="hljs-built_in">view</span>(TypeList&lt;Exclude...&gt; = &#123;&#125;);<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">View</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Group</span>;<br><br></code></pre></td></tr></table></figure>
<h2 id="OOP-API-Design"><a href="#OOP-API-Design" class="headerlink" title="OOP API Design"></a>OOP API Design</h2><p>with the above API, we can desgin the interface like this.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ISystem</span><br>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(Registry &amp; registry)</span> </span>= <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// assuming we want to update animation.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AnimationSystem</span> : <span class="hljs-keyword">public</span> ISystem<br>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(Registry &amp; registry)</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">   </span>&#123;<br>      <span class="hljs-keyword">auto</span> view = registry.<span class="hljs-built_in">view</span>&lt;Animation,Transform&gt;();<br>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> [a,b] : view)  &#123;  <span class="hljs-comment">/*handle logic.*/</span> &#125;<br>   &#125;<br>&#125;<br><span class="hljs-comment">// assuming we want to render some objects into screen.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RenderSystem</span> : <span class="hljs-keyword">public</span> ISystem<br>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(Registry &amp; registry)</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">   </span>&#123;<br>      <span class="hljs-keyword">auto</span> group = registry.<span class="hljs-built_in">group</span>&lt;MeshRenderer,Transform&gt;();<br>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> [b,c] : group) &#123; &#125;<br>   &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h3 id="Problems-2"><a href="#Problems-2" class="headerlink" title="Problems?"></a>Problems?</h3><ul>
<li>look at the interface, what is problem of them?<ul>
<li>First, before the engine executes the <strong>update</strong>, the engine did not which components would be operated within the system.<ul>
<li>it means that we can not analyze <strong>the dependency</strong>. </li>
</ul>
</li>
<li>In practice, especially in game, most system would handle lots of entites/objects in each update/tick. thus, there are lots of redundant API operations.<ul>
<li>like <strong>registry.group&lt;Comp…&gt;</strong> or <strong>registry.view&lt;Comp…&gt;</strong></li>
</ul>
</li>
<li>Third, because there is no dependency information, we can not execute systems <strong>parallelly</strong>. <ul>
<li>since the engine want to use ECS architecture, can we get rid of <strong>OOP</strong> or <strong>virtual function</strong>?</li>
</ul>
</li>
<li>Forth, if two systems want to share data with each other, how can they do ? holding the reference with each other? that’s too bad, not a good desgin and it could case very serious memory problem.</li>
</ul>
</li>
</ul>
<h1 id="ECS-Architecture-at-Final-impression"><a href="#ECS-Architecture-at-Final-impression" class="headerlink" title="ECS Architecture at Final impression"></a>ECS Architecture at Final impression</h1><p>From last part, the code from the architecture might be this.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SystemBuilder</span><br>&#123;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span></span>&#123;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp; system : systems)&#123;<br>          system.<span class="hljs-built_in">update</span>(registry);<br>      &#125;<br>  &#125;<br>  std::vector&lt;ISystem&gt; systems;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>Yes, it works in most cases and it is intuitive, right? but it is not good architecture, even worse.</p>
<p>because we have to pay an extra price to execute <strong>virtual functions</strong> ( maybe is not high, but some people would care…). the next path is get rid of it.</p>
<p>the code will evolute to </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SystemBuilder</span><br>&#123;<br>  <span class="hljs-keyword">using</span> SystemCall = <span class="hljs-built_in">void</span> (*)(ecs::Registry &amp;);<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span></span>&#123;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp; system : systems)<br>      &#123;<br>          <span class="hljs-built_in">system</span>(registry);<br>      &#125;<br>  &#125;<br>  std::vector&lt;SystemCall&gt; systems;<br>&#125;;<br><br><span class="hljs-comment">//define your system function</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">system</span><span class="hljs-params">(ecs::Registry &amp; )</span> </span>&#123;<br>   <span class="hljs-keyword">auto</span> group = registry.<span class="hljs-built_in">group</span>&lt;B,C&gt;();<br>   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> [b,c] : group) &#123; &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>through this way, we have got rid of the virtual function, right? but some people would care there is not context to save state, or save variables.<br>we can use context variable to fix. for example.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">systemA</span><span class="hljs-params">(ecs::Registry &amp; registry)</span> </span>&#123;<br>   <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp; ctx = registry.<span class="hljs-built_in">get_ctx</span>&lt;Env&gt;();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">systemB</span><span class="hljs-params">(ecs::Registry &amp; registry)</span> </span>&#123;<br>   <span class="hljs-keyword">auto</span> &amp; ctx = registry.<span class="hljs-built_in">get_ctx</span>&lt;Env&gt;();<br>   ctx.data = <span class="hljs-keyword">do</span> your logic...;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>but, there still have some problems we did not slove. <strong>Dependency</strong> and <strong>Redundant API</strong>.</p>
<h2 id="IoC-and-Dependency-Injection"><a href="#IoC-and-Dependency-Injection" class="headerlink" title="IoC and Dependency Injection"></a>IoC and Dependency Injection</h2><p>IoC (Inversion of Control) is a design pattern, not a specific technical implemetation. The idea of IoC is to hand over the control of objects that were originally manually created in the program to the framework for management. the <strong>Dependency Injection</strong> is the specific implemetation. </p>
<p>assuming we have a MovementSystem which is handling player’s movement. within the system, we may try to access <strong>DeltaTime</strong>, <strong>Input</strong> which are <strong>global</strong> variable, and try to read and write Player movement data.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> movement&#123;<br>   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">system</span><span class="hljs-params">(ecs::Registry &amp; registry)</span> </span>&#123;<br>      <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp; input = registry.<span class="hljs-built_in">get_ctx</span>&lt;Input&gt;();<br>      <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp; deltaTime = registry.<span class="hljs-built_in">get_ctx</span>&lt;DeltaTime&gt;();<br>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> [player,transform] : registry.<span class="hljs-built_in">view</span>&lt;Player,Transform&gt;())<br>      &#123;<br>         <span class="hljs-comment">//....</span><br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="Inject-Global-Variable"><a href="#Inject-Global-Variable" class="headerlink" title="Inject Global Variable"></a>Inject Global Variable</h3><p>we can notice that, the <strong>Input, DeltaTime</strong> was controlled by user. means user try to get specific component by <strong>registry.get_ctx&lt;Comp&gt;</strong>. but if we hand over the control of <strong>Input, DeltaTime</strong> to framework, what does it look like?</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">system</span><span class="hljs-params">(ecs::Registry &amp; registry, <span class="hljs-type">const</span> Input &amp; input, <span class="hljs-type">const</span> DeltaTime&amp; dt)</span></span>;<br></code></pre></td></tr></table></figure>
<p>through the descriptor of the function, the component Input and DeltaTime was injected into system by framework. </p>
<h3 id="Inject-Entity"><a href="#Inject-Entity" class="headerlink" title="Inject Entity"></a>Inject Entity</h3><p>Continue analyzing the system, in each system we will use <strong>registry.view</strong> or <strong>registry.group</strong> to get list of entities. can we abstract it again through dependency injection?</p>
<p>it means each system would only care about single entity, and the low level framework handle iteration. Sounds great, right? thus the system would evolute to this.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">system</span><span class="hljs-params">(Entity playerEntity, <span class="hljs-type">const</span> Input &amp; input, <span class="hljs-type">const</span> DeltaTime&amp; dt)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">auto</span> [player,transform] = playerEntity;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>but here is another problem, why would the framework know that player entity contains these component(Transform/Player/etc…)? so we need type definition to define player.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> Entity = ecs::Define<br>                  ::Fetech&lt;Player&gt;<br>                  ::Modify&lt;Transform&gt;<br>                  ::To&lt;ecs::EntityTemplate&gt;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">system</span><span class="hljs-params">(Entity playerEntity, <span class="hljs-type">const</span> Input &amp; input, <span class="hljs-type">const</span> DeltaTime&amp; dt)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">auto</span> [player,transform] = playerEntity;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>looks amazing! we use type definition to define player entity and make dependency injection. so in each system, we can not see any other framework/registry. </p>
<p>This is a big step ! </p>
<ul>
<li>Firstly, we get rid of virutal function.</li>
<li>Secondly, we implemented dependency injection. every entity and global variables can be injected by framework. it hints very important idea that is <strong>framework knows the dependency</strong>.</li>
</ul>
<h2 id="Dependency-Graph"><a href="#Dependency-Graph" class="headerlink" title="Dependency Graph"></a>Dependency Graph</h2><p>From the last part, we have a result that is <strong>framework knows the dependency</strong>. this is because we can use one rule to define each system. </p>
<ul>
<li><strong>void system(Entity, Group others, Global&amp; a, const Global&amp; b, …….);</strong></li>
</ul>
<p>the system has variadic arguements. look at the system ,there is another implicit rule, the variable is <strong>readable</strong> if one the variable used <strong>const</strong> modifier, otherwise it is writeable.</p>
<p>from this rule, we can finally analyze the <strong>Dependency Graph</strong> and the execute them parallelly.</p>
<p><img src="/images/ecs/dependency_graph.png" srcset="/img/loading.gif" lazyload alt="Dependency Graph"></p>
<h2 id="Parallel-Execution"><a href="#Parallel-Execution" class="headerlink" title="Parallel Execution"></a>Parallel Execution</h2><p>if we want to execute systems parallelly, the need to know what operation(read/write) did in each system. From last part we used dependency injection to inject variables, and each variable has a modifier to define readable or writeable. so the framework knows the dependency and systems can be dispatched into different threads.</p>
<p>Let’s take a simple example to see how it works.</p>
<p>Assume we have <strong>systemA</strong> and <strong>systemB</strong>, both of them want to read component <strong>A</strong>. so we can dispatch them into different threads, right? because there is no data racing.</p>
<p><img src="/images/ecs/job_system1.png" srcset="/img/loading.gif" lazyload alt="Parallel Execution"></p>
<p>However, if one is read, another is write. they can be executed parallelly because for some systems we did care about the order. but it can also be executed in a single thread to ensure data safe as long as the user specifies the execution order. </p>
<p>based on this rule, each variable could take into consideration. so this is the basic idea for parallel execution.</p>
<p>end……</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Game-Engine/">Game Engine</a>
                    
                  </div>
                
              </div>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/08/01/Learn-Nanite/">
                        <span class="hidden-mobile">Fake-Nanite</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
    
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js" ></script>

  





  <script  src="https://cdn.jsdelivr.net/npm/mermaid@8.8.3/dist/mermaid.min.js" ></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({"theme":"default"});
    }
  </script>







<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
